/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./assets/js/src/boxzilla/animator.js":
/*!********************************************!*\
  !*** ./assets/js/src/boxzilla/animator.js ***!
  \********************************************/
/***/ ((module) => {

eval("const duration = 320;\nfunction css(element, styles) {\n  for (const property of Object.keys(styles)) {\n    element.style[property] = styles[property];\n  }\n}\nfunction initObjectProperties(properties, value) {\n  const newObject = {};\n  for (let i = 0; i < properties.length; i++) {\n    newObject[properties[i]] = value;\n  }\n  return newObject;\n}\nfunction copyObjectProperties(properties, object) {\n  const newObject = {};\n  for (let i = 0; i < properties.length; i++) {\n    newObject[properties[i]] = object[properties[i]];\n  }\n  return newObject;\n}\n\n/**\n * Checks if the given element is currently being animated.\n *\n * @param element\n * @returns {boolean}\n */\nfunction animated(element) {\n  return !!element.getAttribute('data-animated');\n}\n\n/**\n * Toggles the element using the given animation.\n *\n * @param element\n * @param animation Either \"fade\" or \"slide\"\n * @param callbackFn\n */\nfunction toggle(element, animation, callbackFn) {\n  const nowVisible = element.style.display !== 'none' || element.offsetLeft > 0;\n\n  // create clone for reference\n  const clone = element.cloneNode(true);\n  const cleanup = function () {\n    element.removeAttribute('data-animated');\n    element.setAttribute('style', clone.getAttribute('style'));\n    element.style.display = nowVisible ? 'none' : '';\n    if (callbackFn) {\n      callbackFn();\n    }\n  };\n\n  // store attribute so everyone knows we're animating this element\n  element.setAttribute('data-animated', 'true');\n\n  // toggle element visiblity right away if we're making something visible\n  if (!nowVisible) {\n    element.style.display = '';\n  }\n  let hiddenStyles;\n  let visibleStyles;\n\n  // animate properties\n  if (animation === 'slide') {\n    hiddenStyles = initObjectProperties(['height', 'borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'], 0);\n    visibleStyles = {};\n    if (!nowVisible) {\n      const computedStyles = window.getComputedStyle(element);\n      visibleStyles = copyObjectProperties(['height', 'borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'], computedStyles);\n\n      // in some browsers, getComputedStyle returns \"auto\" value. this falls back to getBoundingClientRect() in those browsers since we need an actual height.\n      if (!isFinite(visibleStyles.height)) {\n        const clientRect = element.getBoundingClientRect();\n        visibleStyles.height = clientRect.height;\n      }\n      css(element, hiddenStyles);\n    }\n\n    // don't show a scrollbar during animation\n    element.style.overflowY = 'hidden';\n    animate(element, nowVisible ? hiddenStyles : visibleStyles, cleanup);\n  } else {\n    hiddenStyles = {\n      opacity: 0\n    };\n    visibleStyles = {\n      opacity: 1\n    };\n    if (!nowVisible) {\n      css(element, hiddenStyles);\n    }\n    animate(element, nowVisible ? hiddenStyles : visibleStyles, cleanup);\n  }\n}\nfunction animate(element, targetStyles, fn) {\n  let last = +new Date();\n  const initialStyles = window.getComputedStyle(element);\n  const currentStyles = {};\n  const propSteps = {};\n  for (const property of Object.keys(targetStyles)) {\n    // make sure we have an object filled with floats\n    targetStyles[property] = parseFloat(targetStyles[property]);\n\n    // calculate step size & current value\n    const to = targetStyles[property];\n    const current = parseFloat(initialStyles[property]);\n\n    // is there something to do?\n    if (current === to) {\n      delete targetStyles[property];\n      continue;\n    }\n    propSteps[property] = (to - current) / duration; // points per second\n    currentStyles[property] = current;\n  }\n  const tick = function () {\n    const now = +new Date();\n    const timeSinceLastTick = now - last;\n    let done = true;\n    let step, to, increment, newValue;\n    for (const property of Object.keys(targetStyles)) {\n      step = propSteps[property];\n      to = targetStyles[property];\n      increment = step * timeSinceLastTick;\n      newValue = currentStyles[property] + increment;\n      if (step > 0 && newValue >= to || step < 0 && newValue <= to) {\n        newValue = to;\n      } else {\n        done = false;\n      }\n\n      // store new value\n      currentStyles[property] = newValue;\n      element.style[property] = property !== 'opacity' ? newValue + 'px' : newValue;\n    }\n    last = +new Date();\n    if (!done) {\n      // keep going until we're done for all props\n      window.requestAnimationFrame(tick);\n    } else {\n      // call callback\n      fn && fn();\n    }\n  };\n  tick();\n}\nmodule.exports = {\n  toggle,\n  animate,\n  animated\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/animator.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/box.js":
/*!***************************************!*\
  !*** ./assets/js/src/boxzilla/box.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const defaults = {\n  animation: 'fade',\n  rehide: false,\n  content: '',\n  cookie: null,\n  icon: '&times',\n  screenWidthCondition: null,\n  position: 'center',\n  testMode: false,\n  trigger: false,\n  closable: true\n};\nconst Animator = __webpack_require__(/*! ./animator.js */ \"./assets/js/src/boxzilla/animator.js\");\n\n/**\n * Merge 2 objects, values of the latter overwriting the former.\n *\n * @param obj1\n * @param obj2\n * @returns {*}\n */\nfunction merge(obj1, obj2) {\n  const obj3 = {};\n  for (const attrname of Object.keys(obj1)) {\n    obj3[attrname] = obj1[attrname];\n  }\n  for (const attrname of Object.keys(obj2)) {\n    obj3[attrname] = obj2[attrname];\n  }\n  return obj3;\n}\n\n/**\n * Get the real height of entire document.\n * @returns {number}\n */\nfunction getDocumentHeight() {\n  const body = document.body;\n  const html = document.documentElement;\n  return Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n}\n\n// Box Object\nfunction Box(id, config, fireEvent) {\n  this.id = id;\n  this.fireEvent = fireEvent;\n\n  // store config values\n  this.config = merge(defaults, config);\n\n  // add overlay element to dom and store ref to overlay\n  this.overlay = document.createElement('div');\n  this.overlay.setAttribute('aria-modal', true);\n  this.overlay.style.display = 'none';\n  this.overlay.id = 'boxzilla-overlay-' + this.id;\n  this.overlay.classList.add('boxzilla-overlay');\n  document.body.appendChild(this.overlay);\n\n  // state\n  this.visible = false;\n  this.dismissed = false;\n  this.triggered = false;\n  this.triggerHeight = this.calculateTriggerHeight();\n  this.cookieSet = this.isCookieSet();\n  this.element = null;\n  this.contentElement = null;\n  this.closeIcon = null;\n\n  // create dom elements for this box\n  this.dom();\n\n  // further initialise the box\n  this.events();\n}\n\n// initialise the box\nBox.prototype.events = function () {\n  const box = this;\n\n  // attach event to \"close\" icon inside box\n  if (this.closeIcon) {\n    this.closeIcon.addEventListener('click', evt => {\n      evt.preventDefault();\n      box.dismiss();\n    });\n  }\n  this.element.addEventListener('click', evt => {\n    if (evt.target.tagName === 'A' || evt.target.tagName === 'AREA') {\n      box.fireEvent('box.interactions.link', [box, evt.target]);\n    }\n  }, false);\n  this.element.addEventListener('submit', evt => {\n    box.setCookie();\n    box.fireEvent('box.interactions.form', [box, evt.target]);\n  }, false);\n  this.overlay.addEventListener('click', evt => {\n    const x = evt.offsetX;\n    const y = evt.offsetY;\n\n    // calculate if click was less than 40px outside box to avoid closing it by accident\n    const rect = box.element.getBoundingClientRect();\n    const margin = 40;\n\n    // if click was not anywhere near box, dismiss it.\n    if (x < rect.left - margin || x > rect.right + margin || y < rect.top - margin || y > rect.bottom + margin) {\n      box.dismiss();\n    }\n  });\n};\n\n// generate dom elements for this box\nBox.prototype.dom = function () {\n  const wrapper = document.createElement('div');\n  wrapper.className = 'boxzilla-container boxzilla-' + this.config.position + '-container';\n  const box = document.createElement('div');\n  box.id = 'boxzilla-' + this.id;\n  box.className = 'boxzilla boxzilla-' + this.id + ' boxzilla-' + this.config.position;\n  box.style.display = 'none';\n  wrapper.appendChild(box);\n  let content;\n  if (typeof this.config.content === 'string') {\n    content = document.createElement('div');\n    content.innerHTML = this.config.content;\n  } else {\n    content = this.config.content;\n\n    // make sure element is visible\n    content.style.display = '';\n  }\n  content.className = 'boxzilla-content';\n  box.appendChild(content);\n  if (this.config.closable && this.config.icon) {\n    const closeIcon = document.createElement('span');\n    closeIcon.className = 'boxzilla-close-icon';\n    closeIcon.innerHTML = this.config.icon;\n    closeIcon.setAttribute('aria-label', 'close');\n    box.appendChild(closeIcon);\n    this.closeIcon = closeIcon;\n  }\n  document.body.appendChild(wrapper);\n  this.contentElement = content;\n  this.element = box;\n};\n\n// set (calculate) custom box styling depending on box options\nBox.prototype.setCustomBoxStyling = function () {\n  // reset element to its initial state\n  const origDisplay = this.element.style.display;\n  this.element.style.display = '';\n  this.element.style.overflowY = '';\n  this.element.style.maxHeight = '';\n\n  // get new dimensions\n  const windowHeight = window.innerHeight;\n  const boxHeight = this.element.clientHeight;\n\n  // add scrollbar to box and limit height\n  if (boxHeight > windowHeight) {\n    this.element.style.maxHeight = windowHeight + 'px';\n    this.element.style.overflowY = 'scroll';\n  }\n\n  // set new top margin for boxes which are centered\n  if (this.config.position === 'center') {\n    let newTopMargin = (windowHeight - boxHeight) / 2;\n    newTopMargin = newTopMargin >= 0 ? newTopMargin : 0;\n    this.element.style.marginTop = newTopMargin + 'px';\n  }\n  this.element.style.display = origDisplay;\n};\n\n// toggle visibility of the box\nBox.prototype.toggle = function (show, animate) {\n  show = typeof show === 'undefined' ? !this.visible : show;\n  animate = typeof animate === 'undefined' ? true : animate;\n\n  // is box already at desired visibility?\n  if (show === this.visible) {\n    return false;\n  }\n\n  // is box being animated?\n  if (Animator.animated(this.element)) {\n    return false;\n  }\n\n  // if box should be hidden but is not closable, bail.\n  if (!show && !this.config.closable) {\n    return false;\n  }\n\n  // set new visibility status\n  this.visible = show;\n\n  // calculate new styling rules\n  this.setCustomBoxStyling();\n\n  // trigger event\n  this.fireEvent('box.' + (show ? 'show' : 'hide'), [this]);\n\n  // show or hide box using selected animation\n  if (this.config.position === 'center') {\n    this.overlay.classList.toggle('boxzilla-' + this.id + '-overlay');\n    if (animate) {\n      Animator.toggle(this.overlay, 'fade');\n    } else {\n      this.overlay.style.display = show ? '' : 'none';\n    }\n  }\n  if (animate) {\n    Animator.toggle(this.element, this.config.animation, function () {\n      if (this.visible) {\n        return;\n      }\n      this.contentElement.innerHTML = this.contentElement.innerHTML + '';\n    }.bind(this));\n  } else {\n    this.element.style.display = show ? '' : 'none';\n  }\n  return true;\n};\n\n// show the box\nBox.prototype.show = function (animate) {\n  return this.toggle(true, animate);\n};\n\n// hide the box\nBox.prototype.hide = function (animate) {\n  return this.toggle(false, animate);\n};\n\n// calculate trigger height\nBox.prototype.calculateTriggerHeight = function () {\n  let triggerHeight = 0;\n  if (this.config.trigger) {\n    if (this.config.trigger.method === 'element') {\n      const triggerElement = document.body.querySelector(this.config.trigger.value);\n      if (triggerElement) {\n        const offset = triggerElement.getBoundingClientRect();\n        triggerHeight = offset.top;\n      }\n    } else if (this.config.trigger.method === 'percentage') {\n      triggerHeight = this.config.trigger.value / 100 * getDocumentHeight();\n    }\n  }\n  return triggerHeight;\n};\nBox.prototype.fits = function () {\n  if (!this.config.screenWidthCondition || !this.config.screenWidthCondition.value) {\n    return true;\n  }\n  switch (this.config.screenWidthCondition.condition) {\n    case 'larger':\n      return window.innerWidth > this.config.screenWidthCondition.value;\n    case 'smaller':\n      return window.innerWidth < this.config.screenWidthCondition.value;\n  }\n\n  // meh.. condition should be \"smaller\" or \"larger\", just return true.\n  return true;\n};\nBox.prototype.onResize = function () {\n  this.triggerHeight = this.calculateTriggerHeight();\n  this.setCustomBoxStyling();\n};\n\n// is this box enabled?\nBox.prototype.mayAutoShow = function () {\n  if (this.dismissed) {\n    return false;\n  }\n\n  // check if box fits on given minimum screen width\n  if (!this.fits()) {\n    return false;\n  }\n\n  // if trigger empty or error in calculating triggerHeight, return false\n  if (!this.config.trigger) {\n    return false;\n  }\n\n  // rely on cookie value (show if not set, don't show if set)\n  return !this.cookieSet;\n};\nBox.prototype.mayRehide = function () {\n  return this.config.rehide && this.triggered;\n};\nBox.prototype.isCookieSet = function () {\n  // always show on test mode or when no auto-trigger is configured\n  if (this.config.testMode || !this.config.trigger) {\n    return false;\n  }\n\n  // if either cookie is null or trigger & dismiss are both falsey, don't bother checking.\n  if (!this.config.cookie || !this.config.cookie.triggered && !this.config.cookie.dismissed) {\n    return false;\n  }\n  return new RegExp('(?:^|;)\\\\s{0,}boxzilla_box_' + String(this.id) + '=1\\\\s{0,}(?:;|$)').test(document.cookie);\n};\n\n// set cookie that disables automatically showing the box\nBox.prototype.setCookie = function (hours) {\n  const expiryDate = new Date();\n  expiryDate.setHours(expiryDate.getHours() + hours);\n  document.cookie = 'boxzilla_box_' + this.id + '=1; expires=' + expiryDate.toUTCString() + '; path=/';\n};\nBox.prototype.trigger = function () {\n  const shown = this.show();\n  if (!shown) {\n    return;\n  }\n  this.triggered = true;\n  if (this.config.cookie && this.config.cookie.triggered) {\n    this.setCookie(this.config.cookie.triggered);\n  }\n};\n\n/**\n * Dismisses the box and optionally sets a cookie.\n * @param animate\n * @returns {boolean}\n */\nBox.prototype.dismiss = function (animate) {\n  // only dismiss box if it's currently open.\n  if (!this.visible) {\n    return false;\n  }\n\n  // hide box element\n  this.hide(animate);\n\n  // set cookie\n  if (this.config.cookie && this.config.cookie.dismissed) {\n    this.setCookie(this.config.cookie.dismissed);\n  }\n  this.dismissed = true;\n  this.fireEvent('box.dismiss', [this]);\n  return true;\n};\nmodule.exports = Box;\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/box.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/boxzilla.js":
/*!********************************************!*\
  !*** ./assets/js/src/boxzilla/boxzilla.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Box = __webpack_require__(/*! ./box.js */ \"./assets/js/src/boxzilla/box.js\");\nconst throttle = (__webpack_require__(/*! ./util.js */ \"./assets/js/src/boxzilla/util.js\").throttle);\nconst ExitIntent = __webpack_require__(/*! ./triggers/exit-intent.js */ \"./assets/js/src/boxzilla/triggers/exit-intent.js\");\nconst Scroll = __webpack_require__(/*! ./triggers/scroll.js */ \"./assets/js/src/boxzilla/triggers/scroll.js\");\nconst Pageviews = __webpack_require__(/*! ./triggers/pageviews.js */ \"./assets/js/src/boxzilla/triggers/pageviews.js\");\nconst Time = __webpack_require__(/*! ./triggers/time.js */ \"./assets/js/src/boxzilla/triggers/time.js\");\nlet initialised = false;\nconst boxes = [];\nconst listeners = {};\nfunction onKeyUp(evt) {\n  if (evt.key === 'Escape' || evt.key === 'Esc') {\n    dismiss();\n  }\n}\nfunction recalculateHeights() {\n  boxes.forEach(box => box.onResize());\n}\nfunction onElementClick(evt) {\n  // bubble up to <a> or <area> element\n  let el = evt.target;\n  for (let i = 0; i <= 3; i++) {\n    if (!el || el.tagName === 'A' || el.tagName === 'AREA') {\n      break;\n    }\n    el = el.parentElement;\n  }\n  if (!el || el.tagName !== 'A' && el.tagName !== 'AREA' || !el.href) {\n    return;\n  }\n  const match = el.href.match(/[#&]boxzilla-(.+)/i);\n  if (match && match.length > 1) {\n    toggle(match[1]);\n  }\n}\nfunction trigger(event, args) {\n  listeners[event] && listeners[event].forEach(f => f.apply(null, args));\n}\nfunction on(event, fn) {\n  listeners[event] = listeners[event] || [];\n  listeners[event].push(fn);\n}\nfunction off(event, fn) {\n  listeners[event] && listeners[event].filter(f => f !== fn);\n}\n\n// initialise & add event listeners\nfunction init() {\n  if (initialised) {\n    return;\n  }\n\n  // init triggers\n  ExitIntent(boxes);\n  Pageviews(boxes);\n  Scroll(boxes);\n  Time(boxes);\n  document.body.addEventListener('click', onElementClick, true);\n  window.addEventListener('resize', throttle(recalculateHeights));\n  window.addEventListener('load', recalculateHeights);\n  document.addEventListener('keyup', onKeyUp);\n  trigger('ready');\n  initialised = true; // ensure this function doesn't run again\n}\nfunction create(id, opts) {\n  // preserve backwards compat for minimumScreenWidth option\n  if (typeof opts.minimumScreenWidth !== 'undefined') {\n    opts.screenWidthCondition = {\n      condition: 'larger',\n      value: opts.minimumScreenWidth\n    };\n  }\n  id = String(id);\n  const box = new Box(id, opts, trigger);\n  boxes.push(box);\n  return box;\n}\nfunction get(id) {\n  id = String(id);\n  for (let i = 0; i < boxes.length; i++) {\n    if (boxes[i].id === id) {\n      return boxes[i];\n    }\n  }\n  throw new Error('No box exists with ID ' + id);\n}\n\n// dismiss a single box (or all by omitting id param)\nfunction dismiss(id, animate) {\n  if (id) {\n    get(id).dismiss(animate);\n  } else {\n    boxes.forEach(box => box.dismiss(animate));\n  }\n}\nfunction hide(id, animate) {\n  if (id) {\n    get(id).hide(animate);\n  } else {\n    boxes.forEach(box => box.hide(animate));\n  }\n}\nfunction show(id, animate) {\n  if (id) {\n    get(id).show(animate);\n  } else {\n    boxes.forEach(box => box.show(animate));\n  }\n}\nfunction toggle(id, animate) {\n  if (id) {\n    get(id).toggle(animate);\n  } else {\n    boxes.forEach(box => box.toggle(animate));\n  }\n}\n\n// expose boxzilla object\nconst Boxzilla = {\n  off,\n  on,\n  get,\n  init,\n  create,\n  trigger,\n  show,\n  hide,\n  dismiss,\n  toggle,\n  boxes\n};\nwindow.Boxzilla = Boxzilla;\nif ( true && module.exports) {\n  module.exports = Boxzilla;\n}\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/boxzilla.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/timer.js":
/*!*****************************************!*\
  !*** ./assets/js/src/boxzilla/timer.js ***!
  \*****************************************/
/***/ ((module) => {

eval("const Timer = function () {\n  this.time = 0;\n  this.interval = 0;\n};\nTimer.prototype.tick = function () {\n  this.time++;\n};\nTimer.prototype.start = function () {\n  if (!this.interval) {\n    this.interval = window.setInterval(this.tick.bind(this), 1000);\n  }\n};\nTimer.prototype.stop = function () {\n  if (this.interval) {\n    window.clearInterval(this.interval);\n    this.interval = 0;\n  }\n};\nmodule.exports = Timer;\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/timer.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/triggers/exit-intent.js":
/*!********************************************************!*\
  !*** ./assets/js/src/boxzilla/triggers/exit-intent.js ***!
  \********************************************************/
/***/ ((module) => {

eval("module.exports = function (boxes) {\n  let timeout = null;\n  let touchStart = {};\n  function trigger() {\n    document.documentElement.removeEventListener('mouseleave', onMouseLeave);\n    document.documentElement.removeEventListener('mouseenter', onMouseEnter);\n    document.documentElement.removeEventListener('click', clearTimeout);\n    window.removeEventListener('touchstart', onTouchStart);\n    window.removeEventListener('touchend', onTouchEnd);\n\n    // show boxes with exit intent trigger\n    boxes.forEach(box => {\n      if (box.mayAutoShow() && box.config.trigger.method === 'exit_intent') {\n        box.trigger();\n      }\n    });\n  }\n  function clearTimeout() {\n    if (timeout === null) {\n      return;\n    }\n    window.clearTimeout(timeout);\n    timeout = null;\n  }\n  function onMouseEnter() {\n    clearTimeout();\n  }\n  function getAddressBarY() {\n    if (document.documentMode || /Edge\\//.test(navigator.userAgent)) {\n      return 5;\n    }\n    return 0;\n  }\n  function onMouseLeave(evt) {\n    clearTimeout();\n\n    // did mouse leave at top of window?\n    // add small exception space in the top-right corner\n    if (evt.clientY <= getAddressBarY() && evt.clientX < 0.8 * window.innerWidth) {\n      timeout = window.setTimeout(trigger, 600);\n    }\n  }\n  function onTouchStart() {\n    clearTimeout();\n    touchStart = {\n      timestamp: performance.now(),\n      scrollY: window.scrollY,\n      windowHeight: window.innerHeight\n    };\n  }\n  function onTouchEnd(evt) {\n    clearTimeout();\n\n    // did address bar appear?\n    if (window.innerHeight > touchStart.windowHeight) {\n      return;\n    }\n\n    // allow a tiny tiny margin for error, to not fire on clicks\n    if (window.scrollY + 20 > touchStart.scrollY) {\n      return;\n    }\n    if (performance.now() - touchStart.timestamp > 300) {\n      return;\n    }\n    if (['A', 'INPUT', 'BUTTON'].indexOf(evt.target.tagName) > -1) {\n      return;\n    }\n    timeout = window.setTimeout(trigger, 800);\n  }\n  window.addEventListener('touchstart', onTouchStart);\n  window.addEventListener('touchend', onTouchEnd);\n  document.documentElement.addEventListener('mouseenter', onMouseEnter);\n  document.documentElement.addEventListener('mouseleave', onMouseLeave);\n  document.documentElement.addEventListener('click', clearTimeout);\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/triggers/exit-intent.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/triggers/pageviews.js":
/*!******************************************************!*\
  !*** ./assets/js/src/boxzilla/triggers/pageviews.js ***!
  \******************************************************/
/***/ ((module) => {

eval("module.exports = function (boxes) {\n  let pageviews;\n  try {\n    pageviews = sessionStorage.getItem('boxzilla_pageviews') || 0;\n    sessionStorage.setItem('boxzilla_pageviews', ++pageviews);\n  } catch (e) {\n    pageviews = 0;\n  }\n  window.setTimeout(() => {\n    boxes.forEach(box => {\n      if (box.config.trigger.method === 'pageviews' && pageviews > box.config.trigger.value && box.mayAutoShow()) {\n        box.trigger();\n      }\n    });\n  }, 1000);\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/triggers/pageviews.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/triggers/scroll.js":
/*!***************************************************!*\
  !*** ./assets/js/src/boxzilla/triggers/scroll.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const throttle = (__webpack_require__(/*! ../util.js */ \"./assets/js/src/boxzilla/util.js\").throttle);\nmodule.exports = function (boxes) {\n  // check triggerHeight criteria for all boxes\n  function checkHeightCriteria() {\n    // eslint-disable-next-line no-prototype-builtins\n    let scrollY = window.hasOwnProperty('pageYOffset') ? window.pageYOffset : window.scrollTop;\n    scrollY = scrollY + window.innerHeight * 0.9;\n    boxes.forEach(box => {\n      if (!box.mayAutoShow() || box.triggerHeight <= 0) {\n        return;\n      }\n      if (scrollY > box.triggerHeight) {\n        box.trigger();\n      } else if (box.mayRehide() && scrollY < box.triggerHeight - 5) {\n        // if box may auto-hide and scrollY is less than triggerHeight (with small margin of error), hide box\n        box.hide();\n      }\n    });\n  }\n  window.addEventListener('touchstart', throttle(checkHeightCriteria), true);\n  window.addEventListener('scroll', throttle(checkHeightCriteria), true);\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/triggers/scroll.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/triggers/time.js":
/*!*************************************************!*\
  !*** ./assets/js/src/boxzilla/triggers/time.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Timer = __webpack_require__(/*! ../timer.js */ \"./assets/js/src/boxzilla/timer.js\");\nmodule.exports = function (boxes) {\n  const siteTimer = new Timer();\n  const pageTimer = new Timer();\n  const timers = {\n    start: function () {\n      try {\n        const sessionTime = parseInt(sessionStorage.getItem('boxzilla_timer'));\n        if (sessionTime) {\n          siteTimer.time = sessionTime;\n        }\n      } catch (e) {}\n      siteTimer.start();\n      pageTimer.start();\n    },\n    stop: function () {\n      sessionStorage.setItem('boxzilla_timer', siteTimer.time);\n      siteTimer.stop();\n      pageTimer.stop();\n    }\n  };\n\n  // start timers\n  timers.start();\n\n  // stop timers when leaving page or switching to other tab\n  document.addEventListener('visibilitychange', function () {\n    document.hidden ? timers.stop() : timers.start();\n  });\n  window.addEventListener('beforeunload', function () {\n    timers.stop();\n  });\n  window.setInterval(() => {\n    boxes.forEach(box => {\n      if (box.config.trigger.method === 'time_on_site' && siteTimer.time > box.config.trigger.value && box.mayAutoShow()) {\n        box.trigger();\n      } else if (box.config.trigger.method === 'time_on_page' && pageTimer.time > box.config.trigger.value && box.mayAutoShow()) {\n        box.trigger();\n      }\n    });\n  }, 1000);\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/triggers/time.js?");

/***/ }),

/***/ "./assets/js/src/boxzilla/util.js":
/*!****************************************!*\
  !*** ./assets/js/src/boxzilla/util.js ***!
  \****************************************/
/***/ ((module) => {

eval("function throttle(fn, threshold, scope) {\n  threshold || (threshold = 800);\n  let last;\n  let deferTimer;\n  return function () {\n    const context = scope || this;\n    const now = +new Date();\n    const args = arguments;\n    if (last && now < last + threshold) {\n      // hold on to it\n      clearTimeout(deferTimer);\n      deferTimer = setTimeout(function () {\n        last = now;\n        fn.apply(context, args);\n      }, threshold);\n    } else {\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\nmodule.exports = {\n  throttle\n};\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/boxzilla/util.js?");

/***/ }),

/***/ "./assets/js/src/script.js":
/*!*********************************!*\
  !*** ./assets/js/src/script.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("(function () {\n  const Boxzilla = __webpack_require__(/*! ./boxzilla/boxzilla.js */ \"./assets/js/src/boxzilla/boxzilla.js\");\n  const options = window.boxzilla_options;\n\n  // helper function for setting CSS styles\n  function css(element, styles) {\n    if (styles.background_color) {\n      element.style.background = styles.background_color;\n    }\n    if (styles.color) {\n      element.style.color = styles.color;\n    }\n    if (styles.border_color) {\n      element.style.borderColor = styles.border_color;\n    }\n    if (styles.border_width) {\n      element.style.borderWidth = parseInt(styles.border_width) + 'px';\n    }\n    if (styles.border_style) {\n      element.style.borderStyle = styles.border_style;\n    }\n    if (styles.width) {\n      element.style.maxWidth = parseInt(styles.width) + 'px';\n    }\n  }\n  function createBoxesFromConfig() {\n    // failsafe against including script twice.\n    if (options.inited) {\n      return;\n    }\n\n    // create boxes from options\n    for (var key in options.boxes) {\n      // get opts\n      var boxOpts = options.boxes[key];\n      boxOpts.testMode = isLoggedIn && options.testMode;\n\n      // find box content element, bail if not found\n      var boxContentElement = document.getElementById('boxzilla-box-' + boxOpts.id + '-content');\n      if (!boxContentElement) {\n        continue;\n      }\n\n      // use element as content option\n      boxOpts.content = boxContentElement;\n\n      // create box\n      var box = Boxzilla.create(boxOpts.id, boxOpts);\n\n      // add box slug to box element as classname\n      box.element.className = box.element.className + ' boxzilla-' + boxOpts.post.slug;\n\n      // add custom css to box\n      css(box.element, boxOpts.css);\n      try {\n        box.element.firstChild.firstChild.className += ' first-child';\n        box.element.firstChild.lastChild.className += ' last-child';\n      } catch (e) {}\n\n      // maybe show box right away\n      if (box.fits() && locationHashRefersBox(box)) {\n        box.show();\n      }\n    }\n\n    // set flag to prevent initialising twice\n    options.inited = true;\n\n    // trigger \"done\" event.\n    Boxzilla.trigger('done');\n\n    // maybe open box with MC4WP form in it\n    maybeOpenMailChimpForWordPressBox();\n  }\n  function locationHashRefersBox(box) {\n    if (!window.location.hash || window.location.hash.length === 0) {\n      return false;\n    }\n\n    // parse \"boxzilla-{id}\" from location hash\n    const match = window.location.hash.match(/[#&](boxzilla-\\d+)/);\n    if (!match || typeof match !== 'object' || match.length < 2) {\n      return false;\n    }\n    const elementId = match[1];\n    if (elementId === box.element.id) {\n      return true;\n    } else if (box.element.querySelector('#' + elementId)) {\n      return true;\n    }\n    return false;\n  }\n  function maybeOpenMailChimpForWordPressBox() {\n    if ((typeof window.mc4wp_forms_config !== 'object' || !window.mc4wp_forms_config.submitted_form) && typeof window.mc4wp_submitted_form !== 'object') {\n      return;\n    }\n    const form = window.mc4wp_submitted_form || window.mc4wp_forms_config.submitted_form;\n    const selector = '#' + form.element_id;\n    Boxzilla.boxes.forEach(box => {\n      if (box.element.querySelector(selector)) {\n        box.show();\n      }\n    });\n  }\n\n  // print message when test mode is enabled\n  const isLoggedIn = document.body && document.body.className && document.body.className.indexOf('logged-in') > -1;\n  if (isLoggedIn && options.testMode) {\n    console.log('Boxzilla: Test mode is enabled. Please disable test mode if you\\'re done testing.');\n  }\n\n  // init boxzilla\n  Boxzilla.init();\n  document.addEventListener('DOMContentLoaded', () => {\n    // create JS objects for each box\n    createBoxesFromConfig();\n\n    // fire all events queued up during DOM load\n    window.boxzilla_queue.forEach(q => {\n      const [method, args] = q;\n      Boxzilla[method].apply(null, args);\n    });\n  });\n})();\n\n//# sourceURL=webpack://boxzilla-wp/./assets/js/src/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./assets/js/src/script.js");
/******/ 	
/******/ })()
;